{"dependencies":[{"name":"unist-util-visit-parents","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":227,"column":0,"index":6895},"end":{"line":227,"column":53,"index":6948}}],"key":"iosyYjR2FTMMhn8AjGj/gC4uEE4=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"CONTINUE\", {\n    enumerable: true,\n    get: function () {\n      return _unistUtilVisitParents.CONTINUE;\n    }\n  });\n  Object.defineProperty(exports, \"EXIT\", {\n    enumerable: true,\n    get: function () {\n      return _unistUtilVisitParents.EXIT;\n    }\n  });\n  Object.defineProperty(exports, \"SKIP\", {\n    enumerable: true,\n    get: function () {\n      return _unistUtilVisitParents.SKIP;\n    }\n  });\n  exports.visit = visit;\n  var _unistUtilVisitParents = require(_dependencyMap[0], \"unist-util-visit-parents\");\n  /**\n   * @import {Node as UnistNode, Parent as UnistParent} from 'unist'\n   * @import {VisitorResult} from 'unist-util-visit-parents'\n   */\n\n  /**\n   * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n   *   Test from `unist-util-is`.\n   *\n   *   Note: we have remove and add `undefined`, because otherwise when generating\n   *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n   *   which doesnâ€™t work when publishing on npm.\n   */\n\n  // To do: use types from `unist-util-visit-parents` when itâ€™s released.\n\n  /**\n   * @typedef {(\n   *   Fn extends (value: any) => value is infer Thing\n   *   ? Thing\n   *   : Fallback\n   * )} Predicate\n   *   Get the value of a type guard `Fn`.\n   * @template Fn\n   *   Value; typically function that is a type guard (such as `(x): x is Y`).\n   * @template Fallback\n   *   Value to yield if `Fn` is not a type guard.\n   */\n\n  /**\n   * @typedef {(\n   *   Check extends null | undefined // No test.\n   *   ? Value\n   *   : Value extends {type: Check} // String (type) test.\n   *   ? Value\n   *   : Value extends Check // Partial test.\n   *   ? Value\n   *   : Check extends Function // Function test.\n   *   ? Predicate<Check, Value> extends Value\n   *     ? Predicate<Check, Value>\n   *     : never\n   *   : never // Some other test?\n   * )} MatchesOne\n   *   Check whether a node matches a primitive check in the type system.\n   * @template Value\n   *   Value; typically unist `Node`.\n   * @template Check\n   *   Value; typically `unist-util-is`-compatible test, but not arrays.\n   */\n\n  /**\n   * @typedef {(\n   *   Check extends ReadonlyArray<any>\n   *   ? MatchesOne<Value, Check[number]>\n   *   : MatchesOne<Value, Check>\n   * )} Matches\n   *   Check whether a node matches a check in the type system.\n   * @template Value\n   *   Value; typically unist `Node`.\n   * @template Check\n   *   Value; typically `unist-util-is`-compatible test.\n   */\n\n  /**\n   * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n   *   Number; capped reasonably.\n   */\n\n  /**\n   * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n   *   Increment a number in the type system.\n   * @template {Uint} [I=0]\n   *   Index.\n   */\n\n  /**\n   * @typedef {(\n   *   Node extends UnistParent\n   *   ? Node extends {children: Array<infer Children>}\n   *     ? Child extends Children ? Node : never\n   *     : never\n   *   : never\n   * )} InternalParent\n   *   Collect nodes that can be parents of `Child`.\n   * @template {UnistNode} Node\n   *   All node types in a tree.\n   * @template {UnistNode} Child\n   *   Node to search for.\n   */\n\n  /**\n   * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n   *   Collect nodes in `Tree` that can be parents of `Child`.\n   * @template {UnistNode} Tree\n   *   All node types in a tree.\n   * @template {UnistNode} Child\n   *   Node to search for.\n   */\n\n  /**\n   * @typedef {(\n   *   Depth extends Max\n   *   ? never\n   *   :\n   *     | InternalParent<Node, Child>\n   *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n   * )} InternalAncestor\n   *   Collect nodes in `Tree` that can be ancestors of `Child`.\n   * @template {UnistNode} Node\n   *   All node types in a tree.\n   * @template {UnistNode} Child\n   *   Node to search for.\n   * @template {Uint} [Max=10]\n   *   Max; searches up to this depth.\n   * @template {Uint} [Depth=0]\n   *   Current depth.\n   */\n\n  /**\n   * @typedef {(\n   *   Tree extends UnistParent\n   *     ? Depth extends Max\n   *       ? Tree\n   *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n   *     : Tree\n   * )} InclusiveDescendant\n   *   Collect all (inclusive) descendants of `Tree`.\n   *\n   *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\n   *   > recurse without actually running into an infinite loop, which the\n   *   > previous version did.\n   *   >\n   *   > Practically, a max of `2` is typically enough assuming a `Root` is\n   *   > passed, but it doesnâ€™t improve performance.\n   *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n   *   > Using up to `10` doesnâ€™t hurt or help either.\n   * @template {UnistNode} Tree\n   *   Tree type.\n   * @template {Uint} [Max=10]\n   *   Max; searches up to this depth.\n   * @template {Uint} [Depth=0]\n   *   Current depth.\n   */\n\n  /**\n   * @callback Visitor\n   *   Handle a node (matching `test`, if given).\n   *\n   *   Visitors are free to transform `node`.\n   *   They can also transform `parent`.\n   *\n   *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n   *   descendants to be walked (which is a bug).\n   *\n   *   When adding or removing previous siblings of `node` (or next siblings, in\n   *   case of reverse), the `Visitor` should return a new `Index` to specify the\n   *   sibling to traverse after `node` is traversed.\n   *   Adding or removing next siblings of `node` (or previous siblings, in case\n   *   of reverse) is handled as expected without needing to return a new `Index`.\n   *\n   *   Removing the children property of `parent` still results in them being\n   *   traversed.\n   * @param {Visited} node\n   *   Found node.\n   * @param {Visited extends UnistNode ? number | undefined : never} index\n   *   Index of `node` in `parent`.\n   * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n   *   Parent of `node`.\n   * @returns {VisitorResult}\n   *   What to do next.\n   *\n   *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n   *   An `Action` is treated as a tuple of `[Action]`.\n   *\n   *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n   *   When the `Action` is `EXIT`, that action can be returned.\n   *   When the `Action` is `CONTINUE`, `Index` can be returned.\n   * @template {UnistNode} [Visited=UnistNode]\n   *   Visited node type.\n   * @template {UnistParent} [Ancestor=UnistParent]\n   *   Ancestor type.\n   */\n\n  /**\n   * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n   *   Build a typed `Visitor` function from a node and all possible parents.\n   *\n   *   It will infer which values are passed as `node` and which as `parent`.\n   * @template {UnistNode} Visited\n   *   Node type.\n   * @template {UnistParent} Ancestor\n   *   Parent type.\n   */\n\n  /**\n   * @typedef {(\n   *   BuildVisitorFromMatch<\n   *     Matches<Descendant, Check>,\n   *     Extract<Descendant, UnistParent>\n   *   >\n   * )} BuildVisitorFromDescendants\n   *   Build a typed `Visitor` function from a list of descendants and a test.\n   *\n   *   It will infer which values are passed as `node` and which as `parent`.\n   * @template {UnistNode} Descendant\n   *   Node type.\n   * @template {Test} Check\n   *   Test type.\n   */\n\n  /**\n   * @typedef {(\n   *   BuildVisitorFromDescendants<\n   *     InclusiveDescendant<Tree>,\n   *     Check\n   *   >\n   * )} BuildVisitor\n   *   Build a typed `Visitor` function from a tree and a test.\n   *\n   *   It will infer which values are passed as `node` and which as `parent`.\n   * @template {UnistNode} [Tree=UnistNode]\n   *   Node type.\n   * @template {Test} [Check=Test]\n   *   Test type.\n   */\n\n  /**\n   * Visit nodes.\n   *\n   * This algorithm performs *depth-first* *tree traversal* in *preorder*\n   * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n   *\n   * You can choose for which nodes `visitor` is called by passing a `test`.\n   * For complex tests, you should test yourself in `visitor`, as it will be\n   * faster and will have improved type information.\n   *\n   * Walking the tree is an intensive task.\n   * Make use of the return values of the visitor when possible.\n   * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n   * to check if a node matches, and then perform different operations.\n   *\n   * You can change the tree.\n   * See `Visitor` for more info.\n   *\n   * @overload\n   * @param {Tree} tree\n   * @param {Check} check\n   * @param {BuildVisitor<Tree, Check>} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {Tree} tree\n   * @param {BuildVisitor<Tree>} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {undefined}\n   *\n   * @param {UnistNode} tree\n   *   Tree to traverse.\n   * @param {Visitor | Test} testOrVisitor\n   *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n   * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n   *   Handle each node (when test is omitted, pass `reverse`).\n   * @param {boolean | null | undefined} [maybeReverse=false]\n   *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n   * @returns {undefined}\n   *   Nothing.\n   *\n   * @template {UnistNode} Tree\n   *   Node type.\n   * @template {Test} Check\n   *   `unist-util-is`-compatible test.\n   */\n  function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n    /** @type {boolean | null | undefined} */\n    let reverse;\n    /** @type {Test} */\n    let test;\n    /** @type {Visitor} */\n    let visitor;\n    if (typeof testOrVisitor === 'function' && typeof visitorOrReverse !== 'function') {\n      test = undefined;\n      visitor = testOrVisitor;\n      reverse = visitorOrReverse;\n    } else {\n      // @ts-expect-error: assume the overload with test was given.\n      test = testOrVisitor;\n      // @ts-expect-error: assume the overload with test was given.\n      visitor = visitorOrReverse;\n      reverse = maybeReverse;\n    }\n    (0, _unistUtilVisitParents.visitParents)(tree, test, overload, reverse);\n\n    /**\n     * @param {UnistNode} node\n     * @param {Array<UnistParent>} parents\n     */\n    function overload(node, parents) {\n      const parent = parents[parents.length - 1];\n      const index = parent ? parent.children.indexOf(node) : undefined;\n      return visitor(node, index, parent);\n    }\n  }\n});","lineCount":330,"map":[[7,2,229,0,"Object"],[7,8,229,0],[7,9,229,0,"defineProperty"],[7,23,229,0],[7,24,229,0,"exports"],[7,31,229,0],[8,4,229,0,"enumerable"],[8,14,229,0],[9,4,229,0,"get"],[9,7,229,0],[9,18,229,0,"get"],[9,19,229,0],[10,6,229,0],[10,13,229,0,"_unistUtilVisitParents"],[10,35,229,0],[10,36,229,0,"CONTINUE"],[10,44,229,0],[11,4,229,0],[12,2,229,0],[13,2,229,0,"Object"],[13,8,229,0],[13,9,229,0,"defineProperty"],[13,23,229,0],[13,24,229,0,"exports"],[13,31,229,0],[14,4,229,0,"enumerable"],[14,14,229,0],[15,4,229,0,"get"],[15,7,229,0],[15,18,229,0,"get"],[15,19,229,0],[16,6,229,0],[16,13,229,0,"_unistUtilVisitParents"],[16,35,229,0],[16,36,229,0,"EXIT"],[16,40,229,0],[17,4,229,0],[18,2,229,0],[19,2,229,0,"Object"],[19,8,229,0],[19,9,229,0,"defineProperty"],[19,23,229,0],[19,24,229,0,"exports"],[19,31,229,0],[20,4,229,0,"enumerable"],[20,14,229,0],[21,4,229,0,"get"],[21,7,229,0],[21,18,229,0,"get"],[21,19,229,0],[22,6,229,0],[22,13,229,0,"_unistUtilVisitParents"],[22,35,229,0],[22,36,229,0,"SKIP"],[22,40,229,0],[23,4,229,0],[24,2,229,0],[25,2,278,0,"exports"],[25,9,278,0],[25,10,278,0,"visit"],[25,15,278,0],[25,18,278,0,"visit"],[25,23,278,0],[26,2,227,0],[26,6,227,0,"_unistUtilVisitParents"],[26,28,227,0],[26,31,227,0,"require"],[26,38,227,0],[26,39,227,0,"_dependencyMap"],[26,53,227,0],[27,2,1,0],[28,0,2,0],[29,0,3,0],[30,0,4,0],[32,2,6,0],[33,0,7,0],[34,0,8,0],[35,0,9,0],[36,0,10,0],[37,0,11,0],[38,0,12,0],[39,0,13,0],[41,2,15,0],[43,2,17,0],[44,0,18,0],[45,0,19,0],[46,0,20,0],[47,0,21,0],[48,0,22,0],[49,0,23,0],[50,0,24,0],[51,0,25,0],[52,0,26,0],[53,0,27,0],[54,0,28,0],[56,2,30,0],[57,0,31,0],[58,0,32,0],[59,0,33,0],[60,0,34,0],[61,0,35,0],[62,0,36,0],[63,0,37,0],[64,0,38,0],[65,0,39,0],[66,0,40,0],[67,0,41,0],[68,0,42,0],[69,0,43,0],[70,0,44,0],[71,0,45,0],[72,0,46,0],[73,0,47,0],[74,0,48,0],[75,0,49,0],[77,2,51,0],[78,0,52,0],[79,0,53,0],[80,0,54,0],[81,0,55,0],[82,0,56,0],[83,0,57,0],[84,0,58,0],[85,0,59,0],[86,0,60,0],[87,0,61,0],[88,0,62,0],[90,2,64,0],[91,0,65,0],[92,0,66,0],[93,0,67,0],[95,2,69,0],[96,0,70,0],[97,0,71,0],[98,0,72,0],[99,0,73,0],[100,0,74,0],[102,2,76,0],[103,0,77,0],[104,0,78,0],[105,0,79,0],[106,0,80,0],[107,0,81,0],[108,0,82,0],[109,0,83,0],[110,0,84,0],[111,0,85,0],[112,0,86,0],[113,0,87,0],[114,0,88,0],[115,0,89,0],[117,2,91,0],[118,0,92,0],[119,0,93,0],[120,0,94,0],[121,0,95,0],[122,0,96,0],[123,0,97,0],[124,0,98,0],[126,2,100,0],[127,0,101,0],[128,0,102,0],[129,0,103,0],[130,0,104,0],[131,0,105,0],[132,0,106,0],[133,0,107,0],[134,0,108,0],[135,0,109,0],[136,0,110,0],[137,0,111,0],[138,0,112,0],[139,0,113,0],[140,0,114,0],[141,0,115,0],[142,0,116,0],[143,0,117,0],[145,2,119,0],[146,0,120,0],[147,0,121,0],[148,0,122,0],[149,0,123,0],[150,0,124,0],[151,0,125,0],[152,0,126,0],[153,0,127,0],[154,0,128,0],[155,0,129,0],[156,0,130,0],[157,0,131,0],[158,0,132,0],[159,0,133,0],[160,0,134,0],[161,0,135,0],[162,0,136,0],[163,0,137,0],[164,0,138,0],[165,0,139,0],[166,0,140,0],[167,0,141,0],[168,0,142,0],[169,0,143,0],[171,2,145,0],[172,0,146,0],[173,0,147,0],[174,0,148,0],[175,0,149,0],[176,0,150,0],[177,0,151,0],[178,0,152,0],[179,0,153,0],[180,0,154,0],[181,0,155,0],[182,0,156,0],[183,0,157,0],[184,0,158,0],[185,0,159,0],[186,0,160,0],[187,0,161,0],[188,0,162,0],[189,0,163,0],[190,0,164,0],[191,0,165,0],[192,0,166,0],[193,0,167,0],[194,0,168,0],[195,0,169,0],[196,0,170,0],[197,0,171,0],[198,0,172,0],[199,0,173,0],[200,0,174,0],[201,0,175,0],[202,0,176,0],[203,0,177,0],[204,0,178,0],[205,0,179,0],[206,0,180,0],[207,0,181,0],[208,0,182,0],[210,2,184,0],[211,0,185,0],[212,0,186,0],[213,0,187,0],[214,0,188,0],[215,0,189,0],[216,0,190,0],[217,0,191,0],[218,0,192,0],[219,0,193,0],[221,2,195,0],[222,0,196,0],[223,0,197,0],[224,0,198,0],[225,0,199,0],[226,0,200,0],[227,0,201,0],[228,0,202,0],[229,0,203,0],[230,0,204,0],[231,0,205,0],[232,0,206,0],[233,0,207,0],[234,0,208,0],[235,0,209,0],[237,2,211,0],[238,0,212,0],[239,0,213,0],[240,0,214,0],[241,0,215,0],[242,0,216,0],[243,0,217,0],[244,0,218,0],[245,0,219,0],[246,0,220,0],[247,0,221,0],[248,0,222,0],[249,0,223,0],[250,0,224,0],[251,0,225,0],[253,2,231,0],[254,0,232,0],[255,0,233,0],[256,0,234,0],[257,0,235,0],[258,0,236,0],[259,0,237,0],[260,0,238,0],[261,0,239,0],[262,0,240,0],[263,0,241,0],[264,0,242,0],[265,0,243,0],[266,0,244,0],[267,0,245,0],[268,0,246,0],[269,0,247,0],[270,0,248,0],[271,0,249,0],[272,0,250,0],[273,0,251,0],[274,0,252,0],[275,0,253,0],[276,0,254,0],[277,0,255,0],[278,0,256,0],[279,0,257,0],[280,0,258,0],[281,0,259,0],[282,0,260,0],[283,0,261,0],[284,0,262,0],[285,0,263,0],[286,0,264,0],[287,0,265,0],[288,0,266,0],[289,0,267,0],[290,0,268,0],[291,0,269,0],[292,0,270,0],[293,0,271,0],[294,0,272,0],[295,0,273,0],[296,0,274,0],[297,0,275,0],[298,0,276,0],[299,0,277,0],[300,2,278,7],[300,11,278,16,"visit"],[300,16,278,21,"visit"],[300,17,278,22,"tree"],[300,21,278,26],[300,23,278,28,"testOrVisitor"],[300,36,278,41],[300,38,278,43,"visitorOrReverse"],[300,54,278,59],[300,56,278,61,"maybeReverse"],[300,68,278,73],[300,70,278,75],[301,4,279,2],[302,4,280,2],[302,8,280,6,"reverse"],[302,15,280,13],[303,4,281,2],[304,4,282,2],[304,8,282,6,"test"],[304,12,282,10],[305,4,283,2],[306,4,284,2],[306,8,284,6,"visitor"],[306,15,284,13],[307,4,286,2],[307,8,287,4],[307,15,287,11,"testOrVisitor"],[307,28,287,24],[307,33,287,29],[307,43,287,39],[307,47,288,4],[307,54,288,11,"visitorOrReverse"],[307,70,288,27],[307,75,288,32],[307,85,288,42],[307,87,289,4],[308,6,290,4,"test"],[308,10,290,8],[308,13,290,11,"undefined"],[308,22,290,20],[309,6,291,4,"visitor"],[309,13,291,11],[309,16,291,14,"testOrVisitor"],[309,29,291,27],[310,6,292,4,"reverse"],[310,13,292,11],[310,16,292,14,"visitorOrReverse"],[310,32,292,30],[311,4,293,2],[311,5,293,3],[311,11,293,9],[312,6,294,4],[313,6,295,4,"test"],[313,10,295,8],[313,13,295,11,"testOrVisitor"],[313,26,295,24],[314,6,296,4],[315,6,297,4,"visitor"],[315,13,297,11],[315,16,297,14,"visitorOrReverse"],[315,32,297,30],[316,6,298,4,"reverse"],[316,13,298,11],[316,16,298,14,"maybeReverse"],[316,28,298,26],[317,4,299,2],[318,4,301,2],[318,8,301,2,"visitParents"],[318,30,301,14],[318,31,301,14,"visitParents"],[318,43,301,14],[318,45,301,15,"tree"],[318,49,301,19],[318,51,301,21,"test"],[318,55,301,25],[318,57,301,27,"overload"],[318,65,301,35],[318,67,301,37,"reverse"],[318,74,301,44],[318,75,301,45],[320,4,303,2],[321,0,304,0],[322,0,305,0],[323,0,306,0],[324,4,307,2],[324,13,307,11,"overload"],[324,21,307,19,"overload"],[324,22,307,20,"node"],[324,26,307,24],[324,28,307,26,"parents"],[324,35,307,33],[324,37,307,35],[325,6,308,4],[325,12,308,10,"parent"],[325,18,308,16],[325,21,308,19,"parents"],[325,28,308,26],[325,29,308,27,"parents"],[325,36,308,34],[325,37,308,35,"length"],[325,43,308,41],[325,46,308,44],[325,47,308,45],[325,48,308,46],[326,6,309,4],[326,12,309,10,"index"],[326,17,309,15],[326,20,309,18,"parent"],[326,26,309,24],[326,29,309,27,"parent"],[326,35,309,33],[326,36,309,34,"children"],[326,44,309,42],[326,45,309,43,"indexOf"],[326,52,309,50],[326,53,309,51,"node"],[326,57,309,55],[326,58,309,56],[326,61,309,59,"undefined"],[326,70,309,68],[327,6,310,4],[327,13,310,11,"visitor"],[327,20,310,18],[327,21,310,19,"node"],[327,25,310,23],[327,27,310,25,"index"],[327,32,310,30],[327,34,310,32,"parent"],[327,40,310,38],[327,41,310,39],[328,4,311,2],[329,2,312,0],[330,0,312,1],[330,3]],"functionMap":{"names":["<global>","visit","overload"],"mappings":"AAA;OCqR;EC6B;GDI;CDC"},"hasCjsExports":false},"type":"js/module"}]}
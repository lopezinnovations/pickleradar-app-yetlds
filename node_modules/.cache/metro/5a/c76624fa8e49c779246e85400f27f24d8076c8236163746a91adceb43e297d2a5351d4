{"dependencies":[],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  exports.inlineCode = inlineCode;\n  /**\n   * @import {State} from 'mdast-util-to-markdown'\n   * @import {InlineCode, Parents} from 'mdast'\n   */\n\n  inlineCode.peek = inlineCodePeek;\n\n  /**\n   * @param {InlineCode} node\n   * @param {Parents | undefined} _\n   * @param {State} state\n   * @returns {string}\n   */\n  function inlineCode(node, _, state) {\n    let value = node.value || '';\n    let sequence = '`';\n    let index = -1;\n\n    // If there is a single grave accent on its own in the code, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n      sequence += '`';\n    }\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first or last character are a space, eol, or tick, then pad with spaces.\n    if (/[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || /^`|`$/.test(value))) {\n      value = ' ' + value + ' ';\n    }\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineCode`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index];\n      const expression = state.compilePattern(pattern);\n      /** @type {RegExpExecArray | null} */\n      let match;\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue;\n      while (match = expression.exec(value)) {\n        let position = match.index;\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (value.charCodeAt(position) === 10 /* `\\n` */ && value.charCodeAt(position - 1) === 13 /* `\\r` */) {\n          position--;\n        }\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n      }\n    }\n    return sequence + value + sequence;\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineCodePeek() {\n    return '`';\n  }\n});","lineCount":75,"map":[[7,2,14,0,"exports"],[7,9,14,0],[7,10,14,0,"inlineCode"],[7,20,14,0],[7,23,14,0,"inlineCode"],[7,33,14,0],[8,2,1,0],[9,0,2,0],[10,0,3,0],[11,0,4,0],[13,2,6,0,"inlineCode"],[13,12,6,10],[13,13,6,11,"peek"],[13,17,6,15],[13,20,6,18,"inlineCodePeek"],[13,34,6,32],[15,2,8,0],[16,0,9,0],[17,0,10,0],[18,0,11,0],[19,0,12,0],[20,0,13,0],[21,2,14,7],[21,11,14,16,"inlineCode"],[21,21,14,26,"inlineCode"],[21,22,14,27,"node"],[21,26,14,31],[21,28,14,33,"_"],[21,29,14,34],[21,31,14,36,"state"],[21,36,14,41],[21,38,14,43],[22,4,15,2],[22,8,15,6,"value"],[22,13,15,11],[22,16,15,14,"node"],[22,20,15,18],[22,21,15,19,"value"],[22,26,15,24],[22,30,15,28],[22,32,15,30],[23,4,16,2],[23,8,16,6,"sequence"],[23,16,16,14],[23,19,16,17],[23,22,16,20],[24,4,17,2],[24,8,17,6,"index"],[24,13,17,11],[24,16,17,14],[24,17,17,15],[24,18,17,16],[26,4,19,2],[27,4,20,2],[28,4,21,2],[29,4,22,2],[29,11,22,9],[29,15,22,13,"RegExp"],[29,21,22,19],[29,22,22,20],[29,32,22,30],[29,35,22,33,"sequence"],[29,43,22,41],[29,46,22,44],[29,56,22,54],[29,57,22,55],[29,58,22,56,"test"],[29,62,22,60],[29,63,22,61,"value"],[29,68,22,66],[29,69,22,67],[29,71,22,69],[30,6,23,4,"sequence"],[30,14,23,12],[30,18,23,16],[30,21,23,19],[31,4,24,2],[33,4,26,2],[34,4,27,2],[35,4,28,2],[35,8,29,4],[35,18,29,14],[35,19,29,15,"test"],[35,23,29,19],[35,24,29,20,"value"],[35,29,29,25],[35,30,29,26],[35,35,30,6],[35,45,30,16],[35,46,30,17,"test"],[35,50,30,21],[35,51,30,22,"value"],[35,56,30,27],[35,57,30,28],[35,61,30,32],[35,71,30,42],[35,72,30,43,"test"],[35,76,30,47],[35,77,30,48,"value"],[35,82,30,53],[35,83,30,54],[35,87,30,59],[35,94,30,66],[35,95,30,67,"test"],[35,99,30,71],[35,100,30,72,"value"],[35,105,30,77],[35,106,30,78],[35,107,30,79],[35,109,31,4],[36,6,32,4,"value"],[36,11,32,9],[36,14,32,12],[36,17,32,15],[36,20,32,18,"value"],[36,25,32,23],[36,28,32,26],[36,31,32,29],[37,4,33,2],[39,4,35,2],[40,4,36,2],[41,4,37,2],[42,4,38,2],[43,4,39,2],[44,4,40,2],[45,4,41,2],[46,4,42,2],[46,11,42,9],[46,13,42,11,"index"],[46,18,42,16],[46,21,42,19,"state"],[46,26,42,24],[46,27,42,25,"unsafe"],[46,33,42,31],[46,34,42,32,"length"],[46,40,42,38],[46,42,42,40],[47,6,43,4],[47,12,43,10,"pattern"],[47,19,43,17],[47,22,43,20,"state"],[47,27,43,25],[47,28,43,26,"unsafe"],[47,34,43,32],[47,35,43,33,"index"],[47,40,43,38],[47,41,43,39],[48,6,44,4],[48,12,44,10,"expression"],[48,22,44,20],[48,25,44,23,"state"],[48,30,44,28],[48,31,44,29,"compilePattern"],[48,45,44,43],[48,46,44,44,"pattern"],[48,53,44,51],[48,54,44,52],[49,6,45,4],[50,6,46,4],[50,10,46,8,"match"],[50,15,46,13],[52,6,48,4],[53,6,49,4],[54,6,50,4],[55,6,51,4],[55,10,51,8],[55,11,51,9,"pattern"],[55,18,51,16],[55,19,51,17,"atBreak"],[55,26,51,24],[55,28,51,26],[56,6,53,4],[56,13,53,12,"match"],[56,18,53,17],[56,21,53,20,"expression"],[56,31,53,30],[56,32,53,31,"exec"],[56,36,53,35],[56,37,53,36,"value"],[56,42,53,41],[56,43,53,42],[56,45,53,45],[57,8,54,6],[57,12,54,10,"position"],[57,20,54,18],[57,23,54,21,"match"],[57,28,54,26],[57,29,54,27,"index"],[57,34,54,32],[59,8,56,6],[60,8,57,6],[60,12,58,8,"value"],[60,17,58,13],[60,18,58,14,"charCodeAt"],[60,28,58,24],[60,29,58,25,"position"],[60,37,58,33],[60,38,58,34],[60,43,58,39],[60,45,58,41],[60,46,58,42],[60,60,59,8,"value"],[60,65,59,13],[60,66,59,14,"charCodeAt"],[60,76,59,24],[60,77,59,25,"position"],[60,85,59,33],[60,88,59,36],[60,89,59,37],[60,90,59,38],[60,95,59,43],[60,97,59,45],[60,98,59,46],[60,110,60,8],[61,10,61,8,"position"],[61,18,61,16],[61,20,61,18],[62,8,62,6],[63,8,64,6,"value"],[63,13,64,11],[63,16,64,14,"value"],[63,21,64,19],[63,22,64,20,"slice"],[63,27,64,25],[63,28,64,26],[63,29,64,27],[63,31,64,29,"position"],[63,39,64,37],[63,40,64,38],[63,43,64,41],[63,46,64,44],[63,49,64,47,"value"],[63,54,64,52],[63,55,64,53,"slice"],[63,60,64,58],[63,61,64,59,"match"],[63,66,64,64],[63,67,64,65,"index"],[63,72,64,70],[63,75,64,73],[63,76,64,74],[63,77,64,75],[64,6,65,4],[65,4,66,2],[66,4,68,2],[66,11,68,9,"sequence"],[66,19,68,17],[66,22,68,20,"value"],[66,27,68,25],[66,30,68,28,"sequence"],[66,38,68,36],[67,2,69,0],[69,2,71,0],[70,0,72,0],[71,0,73,0],[72,2,74,0],[72,11,74,9,"inlineCodePeek"],[72,25,74,23,"inlineCodePeek"],[72,26,74,23],[72,28,74,26],[73,4,75,2],[73,11,75,9],[73,14,75,12],[74,2,76,0],[75,0,76,1],[75,3]],"functionMap":{"names":["<global>","inlineCode","inlineCodePeek"],"mappings":"AAA;OCa;CDuD;AEK;CFE"},"hasCjsExports":false},"type":"js/module"}]}